options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Parser)


public class Parser
{
    public static void main(String args[]) throws ParseException {
      	System.out.println("Write an arithmetic expression:");
		Parser parser = new Parser(System.in);
		SimpleNode root = parser.Expression(); // returns reference to root node
        	
		root.dump(""); // prints the tree on the screen

		//System.out.println("Expression value: "+myCalc.eval(root));
    }
	
}

PARSER_END(Parser)

SKIP :
{
	" " | "\r" | "\t" | "//"
}

TOKEN:
{
    	< INTEGER: (["0"-"9"])+ >
	|   < LF: "\n" >
	|   < COMMA: "," >
	|   < LPAR: "(" > |   < RPAR: ")" >
	|   < LBRACE: "{" > | <RBRACE: "}">
	|   < LSBRACE: "[" > | <RSBRACE: "]" >
	|   < PVIRG: ";" >
	|   < FSTOP: ".">
	|   < EXCLM: "!">
	|   < EQUAL:"=">
	|   < OPERATOR:("&&"|"<"|"+"|"-"|"*"|"/")>
	|   < IF:"if">
	|   < ELSE: "else">
	|   < NEW:"new">
	|   < THIS:"this">
	|   < TRUE:"true">
    |   < WHILE:"while">
	|   < FALSE: "false">
    |   < IMPORT: "import" >
    |   < INT: "int" >
    |   < BOOLEAN: "boolean" >
    |   < LENGTH: "length">
    |   < STATIC: "static" >
    |   < MAIN: "main" >
    |   < RET: "return" >
    |   < CLASS : "class">
    |   < EXTENDS : "extends" >
    |   < PUBLIC: "public" > | < PRIVATE : "private" > | < PROTECTED : "protected" >
    |   < STRING: "String">
    |   < VOID: "void" >
    |   < IDENTIFIER: ["A"-"Z", "a"-"z"](["0"-"9", "A"-"Z", "a"-"z", "_"])* >

}

SimpleNode Expression(): {}
{
   Main() {return jjtThis;} // Java code inside brackets
}

void Main() #void : {}
{

        (ImportDeclaration())* ClassDeclaration()
       //TODO restrict main to be only one per class


}

void Statement() #Statement: {}
{
    <LBRACE> (Statement())* <RBRACE>
    | IfStatement()
    | WhileStatement()
    | ExpressionDeclaration()
    | AttribExpr()
}

void IfStatement() #If : {}
{
    <IF> <LPAR> ExpressionDeclaration() <RPAR>
        Statement()
    <ELSE>
        Statement()
}

void WhileStatement() #While : {}
{
    <WHILE>  <LPAR> ExpressionDeclaration() <RPAR>
        Statement()
}

void IdentifierExpression() #void:{}
{
    <IDENTIFIER> (<PVIRG> | AttribExpr())
}

void AttribExpr() #void:{}
{
   [<LSBRACE> ExpressionDeclaration() <RSBRACE> ] <EQUAL> ExpressionDeclaration() <PVIRG>
}


void ExpressionDeclaration() #void: {}
{
        (<INTEGER> #Integer
    |   <TRUE> #True
    |   <FALSE> #False
    |   <IDENTIFIER> #Ident
    |   <THIS> #This
    |   <NEW> (<INT> <LSBRACE> ExpressionDeclaration() <RSBRACE> | <IDENTIFIER> <LPAR> <RPAR> )
    |   <EXCLM> ExpressionDeclaration()
    |   <LPAR> ExpressionDeclaration() <RPAR> )
//        [<OPERATOR> #Operator ExpressionDeclaration()
//    |   <LSBRACE>  ExpressionDeclaration() <RSBRACE>
//    | <FSTOP> (<LENGTH>| <IDENTIFIER> <LPAR> [ExpressionDeclaration() (<COMMA> ExpressionDeclaration() )*] <RPAR>)]


/*RAZÃO CHOISE CONFLICT NAS DUAS PRIMEIRAS PRODUÇÕES??*/
}


void ImportDeclaration() #Imp: {}
{
    <IMPORT> Module() <PVIRG> <LF>
}
void Module() #Module: {}
{
   <IDENTIFIER> [<FSTOP> Module()]
}

/*METHOD DECLRATIONS */
void MethodDeclaration() #MethodDecl : {}
{
    <PUBLIC> (ClassMethod() | MainDeclaration()) [<LF>]
}
void ClassMethod() #ClassMethod : {}
{
    Type() <IDENTIFIER> <LPAR> MethodArgs() <RPAR> [<LF>]
    <LBRACE> [<LF>]
        MethodBody()
    <RBRACE> <LF>
}
void MainDeclaration() #MainDecl : {}
{
   <STATIC> <VOID> <MAIN> <LPAR> <STRING>Array() <IDENTIFIER><RPAR> [<LF>]
   <LBRACE > [<LF>]
          MethodBody()
   <RBRACE> <LF>

}
void MethodArgs() #void : {}
{
    Type() <IDENTIFIER> #MethodArg [<COMMA> MethodArgs()]
}
void MethodBody() #methodBody : {}
{
    (
        VarDeclaration()
        | Statement()
    )*

    <RET> #ret ExpressionDeclaration() <PVIRG> <LF>
}
/*
void Type() #Type : {}
{
    (<INT> | <STRING> | <BOOLEAN> | <IDENTIFIER>)[Array()]//standard java var or object
}
 */

/*VAR DECLARATIONS*/

void Identifier() #Ident: {}
{
   <IDENTIFIER> ["." Identifier()]
}

void Array() #Array : {}
{
    <LSBRACE> <RSBRACE>
}


void VarDeclaration(): {}
{
     Type() Identifier() <PVIRG> <LF>
}

void Type(): {}
{
    LOOKAHEAD(2) <INT> ["[" "]"] #Int
    | <BOOLEAN> #Boolean
    | Identifier()
}


/*CLASS DECLARATION*/


void ClassDeclaration() #ClassDec : {}{
    <CLASS> <IDENTIFIER> [ExtendsDec()] [<LF>]
    <LBRACE> [<LF>]
        ClassContents()
    <RBRACE> <LF>
}

void ExtendsDec() #Extends :{}{
    <EXTENDS> <IDENTIFIER>
}

void ClassContents() :{}{

    (VarDeclaration())*(MethodDeclaration())*
}
